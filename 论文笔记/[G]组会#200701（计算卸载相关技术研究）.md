# 组会#200701（计算卸载相关技术研究）

## 1 多边缘计算平台的计算卸载
### 1.1 优化问题
  - 决策变量：$c_{i,j,s}$（$0-1$决策变量），任务块$i$通过微基站$s$上传并在微小区$j$的边缘服务器被处理
  - 目标函数：所有用户设备的本地执行时延与计算卸载时延的差
  $$E(\bold{c})=\sum\limits_{i,s}\frac{D}{P_i}-\left(\sum\limits_{i,j,s}\left[c_{i,j,s}\left(\frac{R}{T_{i,s}}+\frac{D}{P_m}\right)+\left(1-c_{i,j,s}\right)\frac{D}{P_l}\right]+\sum\limits_{j\ne s}\frac{\alpha c_{i,j,s}R}{T_{i,s}}\right)$$
  - 约束1：每个任务块只能同时被一个虚拟机处理
  $$C_1: \sum\limits_{j}c_{i,j,s}\le{1},\forall{i,s}$$
  - 约束2：单个边缘计算平台的计算资源有限
  $$C_2: \sum\limits_{i\in{U_s}}c_{i,j,s}\le{V},\forall{j,s}$$
  - 约束3：计算卸载的处理时间不大于本地的处理时间
  $$C_3: \sum\limits_{i,j,s}c_{i,j,s}\left(\frac{R_{i,s}}{T_{i,s}}+\frac{D_{i,s}}{P_{m}}\right)+\left(1-c_{i,j,s}\right)\frac{D_{i,s}}{P_l}\le\frac{D_{i,s}}{P_l},\forall i,j,s$$
  - 优化目标：**最大化本地执行时延与计算卸载时延的差**
  $$
  \begin{aligned}
  &\max && E(\bold{c}), \\
  &s.t. && C_1 \sim C_3
  \end{aligned}
  $$

### 1.2 优化问题
  - 决策变量：$\omega_{r,c,\lambda}$（$0-1$决策变量），请求节点$r$的计算任务基于分区$\lambda$迁移给协作节点$c$ 
  - 目标函数：所有用户设备的总能耗
  $$E(\bold{\Omega})=\sum\limits_{r\in R}\sum\limits_{c\in C'}\sum\limits_{\lambda\in\Lambda}\omega_{r,c,\lambda}\mathrm{E}_{r,c,\lambda}$$
  - 约束1：上传时延与计算时延之和不超过计算任务的截止期限
  $$C_1: \sum\limits_{c\in C}\sum\limits_{\lambda\in\Lambda}\omega_{r,c,\lambda}\left[\max\left(\frac{S_{r,\lambda}}{R_{r,c}}+\frac{N_{c,\lambda}}{v_c},\frac{N_{r,\lambda}}{v_r}\right)\right]\le{D_r},\forall r\in R$$
  - 约束2：协作节点消耗的能量不能超过其能耗预算
  $$C_2: \sum\limits_{r\in R}\sum\limits_{\lambda\in\Lambda}\omega_{r,c,\lambda}E_{c,\lambda}\le E_{c}^{\mathrm{bud}},\forall c\in C$$
  - 约束3：每个计算任务要么本地执行，要么将任务的分区调度到一个协作节点
  $$C_3: \sum\limits_{c\in C}\sum\limits_{\lambda\in\Lambda}\omega_{r,c,\lambda}+\omega_{r,C+1,\lambda}=1,\forall r\in R$$
  - 约束4：每个协作节点最多同时接收一个来自其他请求节点的计算任务
  $$C_4: \sum\limits_{r\in R}\sum\limits_{\lambda\in\Lambda}\omega_{r,c,\lambda}\le 1,\forall c\in C$$
  - 优化目标：**最小化执行能耗**
  $$
  \begin{aligned}
  &\max && E(\bold{\Omega}), \\
  &s.t. && C_1 \sim C_4
  \end{aligned}
  $$

### 1.3 相关算法
  - 改进的匈牙利/*Kuhn-Munkres*算法
    - 保证输入矩阵维度为$m\times m$
    - 匈牙利算法寻找完备匹配
      - 如果找到完备匹配，直接返回
      - 如果未找到完备匹配，将$X$部顶标减小$\delta$，$Y$部顶标增加$\delta$，$\delta=\min\limits_{y}\left(wl(x)+wr(y)-graph(x,y)\right)$
      - 如果$\vert\delta\vert\le\epsilon$，将当前探索的节点分配至本地执行
  - *n-GS*算法
    - 核心思路：请求节点发出请求$\Rightarrow$协作节点接受或拒绝$\Rightarrow$未匹配的请求节点再次请求$\Rightarrow$协作节点接受、更换或拒绝$\Rightarrow\cdots\Rightarrow$配对完成
    - $n=1$时，协作节点的评判标准为请求节点偏好值更大者优先（比较了偏好列表的前$1$项）
    - $n=2$时，协作节点的评判标准为请求节点偏好差更大者优先（比较了偏好列表的前$2$项）
    - 是否存在这样的$n$，能保证收敛速度的同时，实现最优的优化效果？
  - 天牛须搜索(*BAS*)算法
    - 算法假设
      -  天牛左右两须位于质心两边
      -  天牛步长*step*与两须之间距离$d_0$的比是固定常数，大天牛（两须距离长）走大步，小天牛走小步
      -  天牛飞到下一步后，头的朝向随机
    - 算法步骤
      - 用$x_l$表示左须坐标，$x_r$表示右须坐标，$x$表示质心坐标，$d_0$表示两须距离，$dir$表示朝向的归一化向量
      - 求出两须坐标$x_l=x+d_0\times dir,x_r=x-d_0\times dir$
      - 求出两须的函数值$f_{left}=f(x_l),f_{right}=f(x_r)$
      - 更新质心坐标$x=x-step\times dir\times\mathrm{sgn}(f_{left}-f_{right})$
    - 技术文档：https://jywang2016.github.io/rBAS_documents/

## 2 软件定义无线网络(*SDWN*)的多用户计算卸载
### 2.1 基于低时延
#### 2.1.1 优化问题
  - 决策变量：$F(x_m,i)$（$0-1$决策变量），用户设备$m$的计算任务卸载到基站$i$的边缘云（$i=0$时为宏基站，否则为微基站）
  - 目标函数：所有用户设备的时延
  $$E(w)=\sum\limits_{m=1}^{M}\sum\limits_{n=1}^{N}\left( T_{m0}F\left\{ x_m=0 \right\}+T_{mn}F\left\{ x_m=n \right\} \right)$$
  - 约束1：通信资源约束
  $$C_1: \sum\limits_{m=1}^{M}w_{mn}F\left\{ x_m=n \right\} \le w_{\max}^{BS}$$
  - 约束2：计算资源约束
  $$C_2: \sum\limits_{m=1}^{M}A_{m}F\left\{ x_m=n \right\} \le C_{\max}^{BS}$$
  - 约束3：能耗约束
  $$C_3: \sum\limits_{m=1}^{M}E_{mn}F\left\{ x_m=n \right\} \le E_{\max}^{BS}$$
  - 优化目标：**减少全部用户设备的延迟**
  $$
  \begin{aligned}
  &\min && E(w), \\
  &s.t. && C_1 \sim C_3
  \end{aligned}
  $$

#### 2.1.2 离散布谷鸟搜索(*Discrete Cuckoo Search, DCS*)算法
  - 算法思想
    - 基于布谷鸟的巢寄生行为以及鸟类的*Levy*飞行行为
    - 每个巢中的卵代表**一个解**，布谷鸟的卵代表**新解**，目标是**利用新解或者潜在的优解替代巢中的劣解**
  - 算法步骤
    - 初始化鸟窝个数$n$，鸟窝位置$p_0=\left[ x_1^{(0)},x_2^{(0)},...,x_n^{(0)} \right]^{\mathrm{T}}$，最佳鸟窝$x_i^{(0)}$与最优解$f_{\mathrm{min}}$
    - 循环下列步骤直至找到最优解或迭代次数达到上限：
      - 位置更新：保留上代**最优鸟窝**$x_i^{t-1}$，其它鸟窝依据*Levy*飞行公式，更新其位置，产生一组新鸟窝$p_{t-1}=\left[ x_{1}^{t-1},x_{2}^{t-1},x_{n}^{t-1} \right]^{\mathrm{T}}$，用**适应值更好的鸟窝代替原鸟窝**(如果不如原鸟窝则不替代)，得到一组较优的鸟窝$g_i=\left[ x_1^{(t)},x_2^{(t)},...,x_n^{(t)} \right]^{\mathrm{T}}$
      - 存安去险：每个鸟蛋被鸟窝主人发现外来鸟蛋的概率为$r$，其中$r \in \left[ 0,1 \right]$服从均匀分布，若$r \lt p_a$，则用**局部随机步行公式更改鸟窝位置**，将得到的新鸟窝的适应值再次对比，得到一组较优的鸟窝$p_i=\left[ x_1^{(t)},x_2^{(t)},...,x_n^{(t)} \right]^{\mathrm{T}}$
      - 输出最优鸟窝位置$x_{b}^{(t)}$和最优值$f_{\mathrm{min}}$
  - 离散化处理
    - 将值映射至$(0,1)$范围内：
    $$D(x_i^{t+1})=\frac{x_i^{t+1}-x^{\mathrm{min}}}{x^{\mathrm{min}}-x^{\mathrm{max}}}$$
    - **离散化处理**（一般地，$D_{th}=0.5$）：
    $$x_i^{t+1}=\begin{cases}1, &if\ D(x_i^{t+1})>D_{th} \cr 0, &otherwise\end{cases}$$

### 2.2 基于智能化
#### 2.2.1 收益模型
  - 通信收益$R_{mn}^{comm}$，式中$\alpha_{mn}$为终端用户的接入费用，$r_{mn}$为传输速率，$\beta_{mn}$为频谱的使用费用，$w_{mn}$为信道带宽
  $$R_{mn}^{comm}=\alpha_{mn}r_{mn}-\beta_{mn}w_{mn}$$
  - 计算收益$R_{mn}^{comp}$，式中$\phi_{mn}$为用户支付的计算费用，$\varphi_{mn}$为边缘云支付的计算费用
  $$R_{mn}^{comp}=\phi_{mn}q_{mn}-\varphi_{mn}e_{mn}$$
  - 缓存收益$R_{mn}^{cache}$，式中$\psi_{mn}$为内容文件缓存在边缘云的存储费用，$\gamma_{mn}$为边缘云支付的回传成本
  $$R_{mn}^{cache}=\psi_{mn}l_{A'_m}-\gamma_{mn}A'_{m}$$

#### 2.2.2 深度*Q*学习算法
  - *Q*学习
    - *Q*学习算法的决策过程基于*MDP*，它可以用五元组来表示，式中，$s_i$为状态空间，$a_i$为动作空间，$P\left(s_i,a_i,s_{i+1}\right)$为系统在状态$s_i$下通过执行动作$a_i$转移到状态$s_{i+1}$的概率，$R\left(s_i,a_i\right)$为系统在状态$s_i$下选择动作$a_i$的立即回报，$Q(s_i,a_i)$为系统在状态$s_i$下选择动作$a_i$的长期回报
    $$\left\{s_i,a_i,P\left(s_i,a_i,s_{i+1}\right),R(s_i,a_i),Q(s_i,a_i)\right\}$$
    - 系统在状态$s_i$下，基于策略$\pi$的长期收益为$V^{\pi}(s_i)$。$\lambda(0<\lambda<1)$为**折扣因子**，评估**历史回报对未来的影响**。$\lambda$越大，训练出的智能体越注重历史经验，否则越注重即时回报
    $$V^{\pi}(s_i)=R_i+\lambda R_{i+1}+\lambda^{2}R_{i+2}+\cdots$$
    - *Q*值是状态和动作的评估
    $$Q(s_i,a_i)=R_i+\lambda V^{\pi}(s_{i+1})$$
    - *Q*值基于下式进行更新，式中$\eta(0<\eta<1)$为学习率
    $$Q_{i+1}(s_i,a_i)=(1-\eta)Q_i(s_i,a_i)+\eta\left[R_i+\lambda \max Q_i(s_{i+1},a_{i+1})\right]$$
  - 深度*Q*学习
    - 状态空间：不同的动作$a_m^{comm}(t),a_m^{cache}(t)$决定了不同的系统状态，系统状态包括用户设备$m$与边缘云$n$的通信、边缘云的缓存$d$
    - 动作空间：由**通信动作与缓存动作**组成，$a_m(t)=\left\{a_m^{comm}(t),a_m^{cache}(t)\right\}$
      - 通信动作$a_m^{comm}(t)=\left[a_{m,1}^{comm}(t),a_{m,2}^{comm}(t),\cdots,a_{m,n}^{comm}(t)\right]$：$a_{m,i}^{comm}(t),i \in \left\{1,2,\cdots,N\right\}$表示在时刻$t$用户设备$m$是否连接到小蜂窝边缘云$i$，取值为$\{0,1\}$，若所有取值均为$0$，代表连接到宏蜂窝边缘云
      - 缓存动作$a_m^{cache}(t)=\left[a_{m,1}^{cache}(t),a_{m,2}^{cache}(t),\cdots,a_{m,n}^{cache}(t)\right]$：$a_{m,j}^{cache}(t),j \in \left\{1,2,\cdots,N\right\}$表示在时刻$t$用户设备$m$的内容文件是否缓存在边缘云$j$，取值为$\{0,1\}$，若所有取值均为$0$，代表缓存在宏蜂窝边缘云
    - 回报函数：最大化通信模型、计算模型、缓存模型的回报值，$R_m(t)=R_{m}^{comm}(t)+R_{m}^{cache}(t)$
      - 通信回报$R_{m}^{comm}(t)$：边缘云中**通信模型所获得的回报值**，
      $$R_m^{comm}(t)=\underbrace{\left(1-a_{m}^{comm}(t)\right)R_{m0}^{comm}}_{宏蜂窝基站边缘云的通信回报}\ \ +\underbrace{\left(a_{m}^{comm}(t)\right)R_{mn}^{comm}}_{小蜂窝基站边缘云的通信回报}$$
      - 缓存回报$R_{m}^{cache}(t)$：内容文件**缓存在边缘云中所获得的回报值**
      $$R_m^{cache}(t)=\underbrace{\left(1-a_{m}^{comm}(t)\right)\left(1-a_{m}^{cache}(t)\right)R_{m0}^{cache}}_{宏蜂窝基站边缘云的缓存回报}\ \ +\underbrace{\left(1-a_{m}^{comm}(t)\right)a_{m}^{cache}(t)R_{m0}^{comp}}_{宏蜂窝基站边缘云的计算回报}\ \\ +\underbrace{a_{m}^{comm}(t)a_{m}^{cache}(t)R_{mn}^{cache}}_{小蜂窝基站边缘云的缓存回报}\ \ +\underbrace{a_{m}^{comm}(t)\left(1-a_{m}^{cache}(t)\right)R_{mn}^{comp}}_{小蜂窝基站边缘云的计算回报}$$

### 2.3 基于经济效益
#### 2.3.1 斯坦卡尔伯格模型
  - 服务提供者：边缘云
  - 消费者：设备
  - 行动策略：计算需求集合$\mathcal{Q}=\{Q_1,Q_2,...Q_M\}$，计算服务定价集合$\mathcal{P}=\{P_1,P_2,...P_N\}$
  - 效用函数：
    - 设备$m$的效用函数$F_m\left(P_n,Q_m,Q_{-m}\right)$：$U_m$为设备满意度，$a$为设备的满意系数，$Q_m$为设备申请的计算需求量，$\varphi_{mj} \in \{0,1\}$表示设备$m$从设备$j$获得的影响系数，且$\varphi_{mj}=\varphi_{jm}$，$D_m$为设备的支付开销，$\zeta$为能耗的系数因子。
    $$
    \begin{aligned}
    & F_m\left(P_n,Q_m,Q_{-m}\right)=U_m(1+\sum\limits_{j=1}^{M}\varphi_{mj}U_j)-D_m-\zeta E_{mn}^T \\
    & 式中，U_m=a\ln(1+Q_m)，D_m=P_nQ_m
    \end{aligned}$$
    - 边缘云$n$的效用函数$G_n(P_n,Q_m)$：$\xi$为能耗的系数因子。
    $$G_n(P_n,Q_m)=\sum\limits_{m=1}^{M}(P_nQ_m-\xi E_n^C)$$
  - 优化目标：边缘云根据设备反馈设置计算其资源最佳价格，设备根据边缘云价格确定所需最佳计算资源量
    - 边缘云$n$的定价
    $$
    \begin{aligned}
    &\max && G_n(P_n|P_{-n}^*,Q^*)\\
    &\ s.t.&& Q^* \in \left[ \underline{Q},\overline{Q} \right],\\
    &\ && P_n^* \in \left[ \underline{P},\overline{P} \right]
    \end{aligned}
    $$
    - 设备$m$的计算资源需求
    $$
    \begin{aligned}
    &\max && F_m(Q_m|P_{n}^*,Q_{-m}) \\
    &\ s.t. && T_{mn} \le T_m^{max} \\
    &\ && Q_m \in \left[\underline{Q},\overline{Q}\right],\\
    &\ && P_n^* \in \left[ \underline{P},\overline{P} \right]
    \end{aligned}$$
    - 式中 $P_{-n}$为除去边缘云$n$之外的其它边缘云的定价集合，$Q_{-m}$为除去设备$m$之外的其它设备的计算资源需求策略集合，$\left[ \underline{P},\overline{P} \right]$为价格集合的上下限，$\left[ \underline{Q},\overline{Q} \right]$为设备计算资源需求的上下限
#### 2.3.2 纳什均衡
  - 纳什均衡点：
    - 设备具有唯一的纳什均衡点
      $$ 
      \begin{aligned}
      &\frac{\partial(F_m\left(P_n,Q_m,Q_{-m}\right))}{\partial Q_m}&&= \frac{a}{1+Q_m}\left(1+\sum\limits_{j=1}^{M}\varphi_{mj}U_j\right)-P_n-\frac{\zeta \rho_{mn}}{r_{mn}}\\
      &\frac{\partial^2(F_m\left(P_n,Q_m,Q_{-m}\right))}{\partial Q_m^2}&&= -\frac{a}{(1+Q_m)^2}\left(1+\sum\limits_{j=1}^{M}\varphi_{mj}U_j\right) \lt 0 \Rightarrow F_m\left(P_n,Q_m,Q_{-m}\right)为凹函数\\
      &令\frac{\partial(F_m\left(P_n,Q_m,Q_{-m}\right))}{\partial Q_m}=0，解得&&Q_m^*=\psi=\left( \frac{ar_{mn}\left(1+\sum\limits_{j=1}^{M}\varphi_{mj}U_j\right)}{r_{mn}P_{n}+\zeta \rho_{mn}}-1\right)
      \end{aligned}
      $$
    - 边缘云具有唯一的纳什均衡点
      $$ 
      \begin{aligned}
      &\frac{\partial(G_n(P_n,Q_m^*))}{\partial P_n}&&= \sum\limits_{m=1}^{M}\left( \frac{ar_{mn}\zeta\rho_{mn}(1+\sum\limits_{j=1}^{M}\varphi_{mj}U_{j})}{\left(r_{mn}P_n+\xi\rho_{mn}\right)^2}-1\right)\\
      &\frac{\partial^2(G_n(P_n,Q_m^*))}{\partial P_n^2}&&= \frac{-2ar_{mn}^2\zeta\rho_{mn}}{\left(P_nr_{mn}+\zeta\rho_{mn}\right)^3}(1+\sum\limits_{j=1}^{M}\varphi_{mj}U_{j}) \lt 0 \Rightarrow G_n(P_n,Q_m^*)为凹函数\\
      &令\frac{\partial(G_n(P_n,Q_m^*))}{\partial P_n}=0，解得&&P_n^*=\phi=\sum\limits_{m=1}^{M}\frac{1}{r_{mn}}\left(\sqrt{ar\zeta\rho_{mn}\left(1+\sum\limits_{j=1}^{M}\varphi_{mj}U_j\right)}-\zeta\rho_{mn}\right)
      \end{aligned}
      $$
#### 2.3.3 梯度下降算法
  - 算法步骤
    - 初始化边缘云定价$P_n$与设备计算资源需求$Q_m$
    - 当$t \lt t_{\max}$时：
      - 更新边缘云$n$的定价：
      $$P_n(t+1)=P_n(t)+\alpha\frac{\partial G_n'}{\partial P_n}$$
      - 当$\tau \lt \tau_{\max}$时：
        - 更新边缘云$n$的定价：
        $$Q_m(\tau+1)=Q_m(\tau)+\beta\frac{\partial F_m'}{\partial Q_m}$$
    - 输出$P_n^*$与$Q_m^*$
  - 算法分析
    - $t_{\max},\tau_{\max}$为边缘云与设备的最大迭代次数，$alpha,\beta$为步长
    - 时间复杂度为$O(N^{t_{\max}} \times M^{\tau_{\max}})$


## 3 软件定义超密集网络(*SD-UDN*)的计算卸载
### 3.1 优化问题
  - 决策变量：$x_i$（$0-1$决策变量，任务$i$在本地/边缘侧处理），$\gamma_i$（处理任务$i$的边缘云），$\kappa_i$（为任务$i$分配的计算资源比例）
  - 目标函数：所有用户设备的平均处理时延
  $$
  \begin{aligned}
  &E(\bold{x,\gamma,\kappa})=\sum\limits_{x=1}^{m}\left[x_{i}t_{i}^{L}+\left(1-x_i\right)t_i^E\right] \\ 
  &式中，t_{i}^{L}=\frac{\omega_i}{f_i^l}，t_i^E=\frac{\omega_i}{\kappa_i^{\gamma_i}f_{\gamma_i}^{c}}+\frac{s_i}{r_{i,\gamma_i}}
  \end{aligned}
  $$
  - 约束1：本地能耗小于移动设备的电量
  $$C_1: x_{i}\epsilon_{i}^{L}\le \alpha_{i}E_{\max}^{i},\forall i=1,\cdots,m$$
  - 约束2：计算卸载能耗小于移动设备的电量
  $$C_2: (1-x_{i})\epsilon_{i}^{E}\le \alpha_{i}E_{\max}^{i},\forall i=1,\cdots,m$$
  - 约束3：只有向用户$u_i$提供服务的边缘云能提供计算卸载
  $$C_3: \gamma_{i}\in A(u_i),\forall i=1,\cdots,m$$
  - 约束4：分配给$\gamma_i$的计算量不超过其计算资源
  $$C_3: \sum\limits_{i\in o_{\gamma_i}}\kappa_{i}^{\gamma_i}\le 1$$
  - 优化目标：**最小化全部用户设备的平均处理时延**
  $$
  \begin{aligned}
  &\min && E(\bold{x,\gamma,\kappa}), \\
  &s.t. && C_1 \sim C_4
  \end{aligned}
  $$
### 3.2 近似算法
#### 3.2.1 *KKT*条件
  - 对于固定的$x_i$与$\gamma_i$，$\kappa_i$的优化问题为凸优化问题（证明方式：证明其*Hessian*矩阵对称正定）
  - 基于*KKT*条件求解
#### 3.2.2 近似算法
  - 简化变量：用$\bold{Z}=(z_{ij})_{m\times(n+m)},z_{ij}\in\{0,1\}$替代$x$与$\gamma$，当$z_{ij}=1$时，任务$i$被卸载到边缘云（$j\le n$）或本地执行（$j=i+n$），此时约束条件变为$\sum\limits_{j=1}^{n+1}z_{ij}=1,i=1,2,\cdots,m$
  - 近似连续：定义连续变量$y_{ij}$，其满足$y_{ij}\ge 0,\sum\limits_{j=1}^{n+1}y_{ij}=1,i=1,2,\cdots,m$，定义线性函数$\phi^t(y_{ij})=\frac{y_{ij}}{y_{ij}^{t-1}+\epsilon}$，式中$t$为迭代次数，用$\phi^t(y_{ij})$替代$\bold{Z}$，则优化问题变为凸问题，可用*KKT*条件求解
  - 迭代求解：
    - 初始状态下，$y_{ij}^0=1-\epsilon$
    - $t=t+1$，将上一步求解出的$y_{ij}$记做$y_{ij}^{t-1}$，求解$\phi^t(y_{ij})$
    - 用$\phi^t(y_{ij})$替换$\bold{Z}$，依据*KKT*条件求解出$y_{ij}$
    - 如果$\vert{y_{ij}^t-y_{ij}^{t-1}}\vert\lt\delta$，则$y_{ij}^*=y_{ij}^t$，否则继续迭代